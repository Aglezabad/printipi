<?xml version='1.0' encoding='utf-8'?>
<namespace id="tupleutil" name="tupleutil" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <functiontemplate id="tupleutil::callOnAll" name="callOnAll">
    <brief>Apply @f(item, @args...) for each item in the tuple @t</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="tupleutil::callOnAll::t" name="t">
      <type name="TupleT" qualifier=" &amp;" />
    </argument>
    <argument id="tupleutil::callOnAll::f" name="f">
      <type name="Func" />
    </argument>
    <argument id="tupleutil::callOnAll::args" name="args">
      <type name="Args..." />
    </argument>
    <templatetypeparameter id="tupleutil::callOnAll::TupleT" name="TupleT" />
    <templatetypeparameter id="tupleutil::callOnAll::Func" name="Func" />
    <templatetypeparameter id="tupleutil::callOnAll::Args" name="Args" />
  </functiontemplate>
  <functiontemplate id="tupleutil::callOnAll" name="callOnAll">
    <brief>Apply @f(item, @args...) for each item in the tuple @t</brief>
    <doc>This second version allows to pass a function object by pointer, so that it can perhaps be modified. TODO: Maybe just use an auto reference (Func &amp;&amp;f)?</doc>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="tupleutil::callOnAll::t" name="t">
      <type name="TupleT" qualifier=" &amp;" />
    </argument>
    <argument id="tupleutil::callOnAll::f" name="f">
      <type name="Func" qualifier="*" />
    </argument>
    <argument id="tupleutil::callOnAll::args" name="args">
      <type name="Args..." />
    </argument>
    <templatetypeparameter id="tupleutil::callOnAll::TupleT" name="TupleT" />
    <templatetypeparameter id="tupleutil::callOnAll::Func" name="Func" />
    <templatetypeparameter id="tupleutil::callOnAll::Args" name="Args" />
  </functiontemplate>
  <functiontemplate id="tupleutil::tupleCallOnIndex" name="tupleCallOnIndex">
    <brief>Return @f(@t[@idx], args...)</brief>
    <doc>Note: if @idx &gt; the size of the tuple, behavior is undefined.
Most likely, that would result in applying @f to the last item in the tuple (but no guarantee)</doc>
    <return>
      <type name="decltype(__callOnIndex&lt;TupleT, std::tuple_size&lt;TupleT&gt;::value, Func, Args...&gt;()(t, f, idx, args...))" />
    </return>
    <argument id="tupleutil::tupleCallOnIndex::t" name="t">
      <type name="TupleT" qualifier=" &amp;" />
    </argument>
    <argument id="tupleutil::tupleCallOnIndex::f" name="f">
      <type name="Func" />
    </argument>
    <argument id="tupleutil::tupleCallOnIndex::idx" name="idx">
      <type name="std::size_t" />
    </argument>
    <argument id="tupleutil::tupleCallOnIndex::args" name="args">
      <type name="Args..." />
    </argument>
    <templatetypeparameter id="tupleutil::tupleCallOnIndex::TupleT" name="TupleT" />
    <templatetypeparameter id="tupleutil::tupleCallOnIndex::Func" name="Func" />
    <templatetypeparameter id="tupleutil::tupleCallOnIndex::Args" name="Args" />
  </functiontemplate>
  <functiontemplate id="tupleutil::tupleReduce" name="tupleReduce">
    <brief>Apply @r( @r( d, @f(@t[0], @args...) ), @f(@t[1], @args...) ), ...</brief>
    <doc>This function is also sometime known as "fold".
If, for example, the reducing function @r sums its two arguments, then the result will be the sum of ALL items in the tuple.</doc>
    <return>
      <type name="decltype(d)" />
    </return>
    <argument id="tupleutil::tupleReduce::t" name="t">
      <type name="TupleT" qualifier=" &amp;" />
    </argument>
    <argument id="tupleutil::tupleReduce::f" name="f">
      <type name="Func" />
    </argument>
    <argument id="tupleutil::tupleReduce::r" name="r">
      <type name="Reduce" />
    </argument>
    <argument id="tupleutil::tupleReduce::d" name="d">
      <type name="ReducedDefault" />
    </argument>
    <argument id="tupleutil::tupleReduce::args" name="args">
      <type name="Args..." />
    </argument>
    <templatetypeparameter id="tupleutil::tupleReduce::TupleT" name="TupleT" />
    <templatetypeparameter id="tupleutil::tupleReduce::Func" name="Func" />
    <templatetypeparameter id="tupleutil::tupleReduce::Reduce" name="Reduce" />
    <templatetypeparameter id="tupleutil::tupleReduce::ReducedDefault" name="ReducedDefault" />
    <templatetypeparameter id="tupleutil::tupleReduce::Args" name="Args" />
  </functiontemplate>
  <functiontemplate id="tupleutil::tupleReduceLogicalOr" name="tupleReduceLogicalOr">
    <brief>Return @f(@t[0], args...) || @f(@t[1], args...) || @f(@t[2], args...) || ...</brief>
    <return>
      <type builtin="yes" name="bool" />
    </return>
    <argument id="tupleutil::tupleReduceLogicalOr::t" name="t">
      <type name="TupleT" qualifier=" &amp;" />
    </argument>
    <argument id="tupleutil::tupleReduceLogicalOr::f" name="f">
      <type name="Func" />
    </argument>
    <argument id="tupleutil::tupleReduceLogicalOr::args" name="args">
      <type name="Args..." />
    </argument>
    <templatetypeparameter id="tupleutil::tupleReduceLogicalOr::TupleT" name="TupleT" />
    <templatetypeparameter id="tupleutil::tupleReduceLogicalOr::Func" name="Func" />
    <templatetypeparameter id="tupleutil::tupleReduceLogicalOr::Args" name="Args" />
  </functiontemplate>
  <namespace name="(anonymous::1)" ref="tupleutil::(anonymous::1)#tupleutil::(anonymous::1)" />
</namespace>
