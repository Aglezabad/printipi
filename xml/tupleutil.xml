<?xml version='1.0' encoding='utf-8'?>
<namespace id="tupleutil" name="tupleutil" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <doc>
This namespace provides utilities for manipulating tuples.
Namely, it provides a way to apply a polymorphic (templated) function to each item in a tuple (callOnAll)
Or call a function with the nth element of a tuple, where n is not a compile-time constant. (tupleCallOnIndex)
</doc>
  <functiontemplate id="tupleutil::callOnAll" name="callOnAll">
    <brief>Apply @f(item, @args...) for each item in the tuple @t</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="tupleutil::callOnAll::t" name="t">
      <type name="TupleT" qualifier=" &amp;" />
    </argument>
    <argument id="tupleutil::callOnAll::f" name="f">
      <type name="Func" />
    </argument>
    <argument id="tupleutil::callOnAll::args" name="args">
      <type name="Args..." />
    </argument>
    <templatetypeparameter id="tupleutil::callOnAll::TupleT" name="TupleT" />
    <templatetypeparameter id="tupleutil::callOnAll::Func" name="Func" />
    <templatetypeparameter id="tupleutil::callOnAll::Args" name="Args" />
  </functiontemplate>
  <functiontemplate id="tupleutil::callOnAll" name="callOnAll">
    <brief>Apply @f(item, @args...) for each item in the tuple @t</brief>
    <doc>This second version allows to pass a function object by pointer, so that it can perhaps be modified. TODO: Maybe just use an auto reference (Func &amp;&amp;f)?</doc>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="tupleutil::callOnAll::t" name="t">
      <type name="TupleT" qualifier=" &amp;" />
    </argument>
    <argument id="tupleutil::callOnAll::f" name="f">
      <type name="Func" qualifier="*" />
    </argument>
    <argument id="tupleutil::callOnAll::args" name="args">
      <type name="Args..." />
    </argument>
    <templatetypeparameter id="tupleutil::callOnAll::TupleT" name="TupleT" />
    <templatetypeparameter id="tupleutil::callOnAll::Func" name="Func" />
    <templatetypeparameter id="tupleutil::callOnAll::Args" name="Args" />
  </functiontemplate>
  <functiontemplate id="tupleutil::tupleCallOnIndex" name="tupleCallOnIndex">
    <brief>Return @f(@t[@idx], args...)</brief>
    <doc>Note: if @idx &gt; the size of the tuple, behavior is undefined.
Most likely, that would result in applying @f to the last item in the tuple (but no guarantee)</doc>
    <return>
      <type name="decltype(__callOnIndex&lt;TupleT, std::tuple_size&lt;TupleT&gt;::value, Func, Args...&gt;()(t, f, idx, args...))" />
    </return>
    <argument id="tupleutil::tupleCallOnIndex::t" name="t">
      <type name="TupleT" qualifier=" &amp;" />
    </argument>
    <argument id="tupleutil::tupleCallOnIndex::f" name="f">
      <type name="Func" />
    </argument>
    <argument id="tupleutil::tupleCallOnIndex::idx" name="idx">
      <type name="std::size_t" />
    </argument>
    <argument id="tupleutil::tupleCallOnIndex::args" name="args">
      <type name="Args..." />
    </argument>
    <templatetypeparameter id="tupleutil::tupleCallOnIndex::TupleT" name="TupleT" />
    <templatetypeparameter id="tupleutil::tupleCallOnIndex::Func" name="Func" />
    <templatetypeparameter id="tupleutil::tupleCallOnIndex::Args" name="Args" />
  </functiontemplate>
  <namespace name="(anonymous::1)" ref="tupleutil::(anonymous::1)#tupleutil::(anonymous::1)">
    <brief>internal functions - treat as private</brief>
  </namespace>
</namespace>
