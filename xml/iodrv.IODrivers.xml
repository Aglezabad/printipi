<?xml version='1.0' encoding='utf-8'?>
<classtemplate id="iodrv::IODrivers" name="IODrivers" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <doc>
Container type for IODrivers.
Provides several conveniences, like iterators and filtering
  while still maintaining type-information for each item
</doc>
  <templatetypeparameter id="iodrv::IODrivers::TupleT" name="TupleT" />
  <constructor id="iodrv::IODrivers::IODrivers&lt;TupleT&gt;" name="IODrivers&lt;TupleT&gt;">
    <brief>@ioDrivers std::tuple of IODrivers to construct from (will be moved).</brief>
    <doc>Eg IODrivers(std::make_tuple(Fan(), A4988(), Endstop()))</doc>
    <argument id="iodrv::IODrivers::IODrivers&lt;TupleT&gt;::ioDrivers" name="ioDrivers">
      <type name="TupleT &amp;&amp;" />
    </argument>
  </constructor>
  <method id="iodrv::IODrivers::tuple" name="tuple">
    <brief>@return a reference to the underlying tuple of IODrivers</brief>
    <return>
      <type name="TupleT" qualifier=" &amp;" />
    </return>
  </method>
  <class name="iteratorbase" ref="iodrv::IODrivers::iteratorbase#iodrv::IODrivers::iteratorbase" />
  <typedef id="iodrv::IODrivers::GenericLockAxis" name="GenericLockAxis">
    <brief>Wrap the generic functions to either accept (driver, args...) or (index, driver, args...) as function arguments</brief>
    <doc>The index argument is provided by tupleutil::callOn*, but other places (e.g. predicates) expect no index argument.</doc>
    <type name="IODrivers&lt;TupleT&gt;::IndexOptional&lt;T&gt;" ref="iodrv::IODrivers::IndexOptional#iodrv::IODrivers::IndexOptional" />
  </typedef>
  <typedef id="iodrv::IODrivers::GenericUnlockAxis" name="GenericUnlockAxis">
    <type name="IODrivers&lt;TupleT&gt;::IndexOptional&lt;T&gt;" ref="iodrv::IODrivers::IndexOptional#iodrv::IODrivers::IndexOptional" />
  </typedef>
  <typedef id="iodrv::IODrivers::GenericIsFan" name="GenericIsFan">
    <type name="IODrivers&lt;TupleT&gt;::IndexOptional&lt;T&gt;" ref="iodrv::IODrivers::IndexOptional#iodrv::IODrivers::IndexOptional" />
  </typedef>
  <typedef id="iodrv::IODrivers::GenericIsHotend" name="GenericIsHotend">
    <type name="IODrivers&lt;TupleT&gt;::IndexOptional&lt;T&gt;" ref="iodrv::IODrivers::IndexOptional#iodrv::IODrivers::IndexOptional" />
  </typedef>
  <typedef id="iodrv::IODrivers::GenericIsHeatedBed" name="GenericIsHeatedBed">
    <type name="IODrivers&lt;TupleT&gt;::IndexOptional&lt;T&gt;" ref="iodrv::IODrivers::IndexOptional#iodrv::IODrivers::IndexOptional" />
  </typedef>
  <typedef id="iodrv::IODrivers::GenericIsServo" name="GenericIsServo">
    <type name="IODrivers&lt;TupleT&gt;::IndexOptional&lt;T&gt;" ref="iodrv::IODrivers::IndexOptional#iodrv::IODrivers::IndexOptional" />
  </typedef>
  <typedef id="iodrv::IODrivers::GenericIsEndstop" name="GenericIsEndstop">
    <type name="IODrivers&lt;TupleT&gt;::IndexOptional&lt;T&gt;" ref="iodrv::IODrivers::IndexOptional#iodrv::IODrivers::IndexOptional" />
  </typedef>
  <typedef id="iodrv::IODrivers::GenericIsEndstopTriggered" name="GenericIsEndstopTriggered">
    <type name="IODrivers&lt;TupleT&gt;::IndexOptional&lt;T&gt;" ref="iodrv::IODrivers::IndexOptional#iodrv::IODrivers::IndexOptional" />
  </typedef>
  <typedef id="iodrv::IODrivers::GenericSetFanDutyCycle" name="GenericSetFanDutyCycle">
    <type name="IODrivers&lt;TupleT&gt;::IndexOptional&lt;T&gt;" ref="iodrv::IODrivers::IndexOptional#iodrv::IODrivers::IndexOptional" />
  </typedef>
  <typedef id="iodrv::IODrivers::GenericSetTargetTemperature" name="GenericSetTargetTemperature">
    <type name="IODrivers&lt;TupleT&gt;::IndexOptional&lt;T&gt;" ref="iodrv::IODrivers::IndexOptional#iodrv::IODrivers::IndexOptional" />
  </typedef>
  <typedef id="iodrv::IODrivers::GenericGetTargetTemperature" name="GenericGetTargetTemperature">
    <type name="IODrivers&lt;TupleT&gt;::IndexOptional&lt;T&gt;" ref="iodrv::IODrivers::IndexOptional#iodrv::IODrivers::IndexOptional" />
  </typedef>
  <typedef id="iodrv::IODrivers::GenericGetMeasuredTemperature" name="GenericGetMeasuredTemperature">
    <type name="IODrivers&lt;TupleT&gt;::IndexOptional&lt;T&gt;" ref="iodrv::IODrivers::IndexOptional#iodrv::IODrivers::IndexOptional" />
  </typedef>
  <typedef id="iodrv::IODrivers::GenericSetServoAngleDegrees" name="GenericSetServoAngleDegrees">
    <type name="IODrivers&lt;TupleT&gt;::IndexOptional&lt;T&gt;" ref="iodrv::IODrivers::IndexOptional#iodrv::IODrivers::IndexOptional" />
  </typedef>
  <typedef id="iodrv::IODrivers::GenericPeekNextEvent" name="GenericPeekNextEvent">
    <type name="IODrivers&lt;TupleT&gt;::IndexOptional&lt;T&gt;" ref="iodrv::IODrivers::IndexOptional#iodrv::IODrivers::IndexOptional" />
  </typedef>
  <typedef id="iodrv::IODrivers::GenericConsumeNextEvent" name="GenericConsumeNextEvent">
    <type name="IODrivers&lt;TupleT&gt;::IndexOptional&lt;T&gt;" ref="iodrv::IODrivers::IndexOptional#iodrv::IODrivers::IndexOptional" />
  </typedef>
  <typedef id="iodrv::IODrivers::GenericOnIdleCpu" name="GenericOnIdleCpu">
    <type name="IODrivers&lt;TupleT&gt;::IndexOptional&lt;T&gt;" ref="iodrv::IODrivers::IndexOptional#iodrv::IODrivers::IndexOptional" />
  </typedef>
  <class name="iteratorbase" ref="iodrv::IODrivers::iteratorbase#iodrv::IODrivers::iteratorbase">
    <brief>Base type for iterators.</brief>
  </class>
  <classtemplate name="iterator" ref="iodrv::IODrivers::iterator#iodrv::IODrivers::iterator">
    <brief>iterator class that also supports a filter predicate.</brief>
    <templatetypeparameter id="iodrv::IODrivers::iterator::Predicate" name="Predicate">
      <brief>function that should return false for any item that is not part of the desired set.</brief>
      <doc>Note that the Predicate function cannot easily store state info, as it may be instantiated for each item.</doc>
      <default>
        <type name="iodrv::IODrivers&lt;TupleT&gt;::NoPredicate" ref="iodrv::IODrivers::NoPredicate#iodrv::IODrivers::NoPredicate" />
      </default>
    </templatetypeparameter>
  </classtemplate>
  <enum anonymous="yes" id="iodrv::IODrivers::ShortCircuitType" name="ShortCircuitType">
    <brief>short-circuit options used in the all() and any() functions</brief>
    <enumvalue id="iodrv::IODrivers::NO_SHORT_CIRCUIT" name="NO_SHORT_CIRCUIT" value="0" />
    <enumvalue id="iodrv::IODrivers::DO_SHORT_CIRCUIT" name="DO_SHORT_CIRCUIT" value="0" />
  </enum>
  <classtemplate name="iterinfo" ref="iodrv::IODrivers::iterinfo#iodrv::IODrivers::iterinfo">
    <brief>Allow one to build a filter before iterating.</brief>
    <templatetypeparameter id="iodrv::IODrivers::iterinfo::Predicate" name="Predicate">
      <default>
        <type name="iodrv::IODrivers&lt;TupleT&gt;::NoPredicate" ref="iodrv::IODrivers::NoPredicate#iodrv::IODrivers::NoPredicate" />
      </default>
    </templatetypeparameter>
  </classtemplate>
  <method id="iodrv::IODrivers::iter" name="iter">
    <brief>return an iterable/indexable object containing ALL the iodrivers</brief>
    <return>
      <type name="IODrivers&lt;TupleT&gt;::iterinfo&lt;Predicate&gt;" ref="iodrv::IODrivers::iterinfo#iodrv::IODrivers::iterinfo" />
    </return>
  </method>
  <method id="iodrv::IODrivers::begin" name="begin">
    <brief>begin iterator for the set of all IODrivers</brief>
    <return>
      <type name="IODrivers&lt;TupleT&gt;::iterator&lt;Predicate&gt;" ref="iodrv::IODrivers::iterator#iodrv::IODrivers::iterator" />
    </return>
  </method>
  <method id="iodrv::IODrivers::end" name="end">
    <brief>end iterator for the set of all IODrivers</brief>
    <return>
      <type name="IODrivers&lt;TupleT&gt;::iterator&lt;Predicate&gt;" ref="iodrv::IODrivers::iterator#iodrv::IODrivers::iterator" />
    </return>
  </method>
  <method id="iodrv::IODrivers::operator[]" name="operator[]">
    <brief>access an IODriver by index</brief>
    <return>
      <type name="IODrivers&lt;TupleT&gt;::iterator&lt;Predicate&gt;" ref="iodrv::IODrivers::iterator#iodrv::IODrivers::iterator" />
    </return>
    <argument id="iodrv::IODrivers::operator[]::idx" name="idx">
      <type name="std::size_t" />
    </argument>
  </method>
  <methodtemplate id="iodrv::IODrivers::filter" name="filter">
    <brief>obtain the set of all IODrivers that pass the filter Predicate.</brief>
    <doc>The predicate should accept an IODriver::iteratorbase as its argument
and return true if that IODriver is to be included in the set.
The predicate is passed by value to achieve type deduction, but a new Predicate may be instantiated for each IODriver.
</doc>
    <return>
      <doc>an iterable <ref ref="iodrv::IODrivers::iterinfo#iodrv::IODrivers::iterinfo">iodrv::IODrivers::iterinfo</ref> object based on the Predicate</doc>
      <type name="IODrivers&lt;TupleT&gt;::iterinfo&lt;Predicate&gt;" ref="iodrv::IODrivers::iterinfo#iodrv::IODrivers::iterinfo" />
    </return>
    <argument id="iodrv::IODrivers::filter::p" name="p">
      <type name="const Predicate" qualifier=" const &amp;" />
    </argument>
    <templatetypeparameter id="iodrv::IODrivers::filter::Predicate" name="Predicate" />
  </methodtemplate>
  <method id="iodrv::IODrivers::fans" name="fans">
    <brief>@return an iterable <ref ref="iodrv::IODrivers::iterinfo#iodrv::IODrivers::iterinfo">iodrv::IODrivers::iterinfo</ref> object that contains only the fan IODrivers</brief>
    <return>
      <type name="IODrivers&lt;TupleT&gt;::iterinfo&lt;Predicate&gt;" ref="iodrv::IODrivers::iterinfo#iodrv::IODrivers::iterinfo" />
    </return>
  </method>
  <method id="iodrv::IODrivers::hotends" name="hotends">
    <brief>@return an iterable <ref ref="iodrv::IODrivers::iterinfo#iodrv::IODrivers::iterinfo">iodrv::IODrivers::iterinfo</ref> object that contains only the hotend IODrivers</brief>
    <return>
      <type name="IODrivers&lt;TupleT&gt;::iterinfo&lt;Predicate&gt;" ref="iodrv::IODrivers::iterinfo#iodrv::IODrivers::iterinfo" />
    </return>
  </method>
  <method id="iodrv::IODrivers::heatedBeds" name="heatedBeds">
    <brief>@return an iterable <ref ref="iodrv::IODrivers::iterinfo#iodrv::IODrivers::iterinfo">iodrv::IODrivers::iterinfo</ref> object that contains only the heated bed IODrivers</brief>
    <return>
      <type name="IODrivers&lt;TupleT&gt;::iterinfo&lt;Predicate&gt;" ref="iodrv::IODrivers::iterinfo#iodrv::IODrivers::iterinfo" />
    </return>
  </method>
  <method id="iodrv::IODrivers::heaters" name="heaters">
    <return>
      <type name="decltype(std::declval&lt;IODrivers&lt;TupleT&gt; &gt;().hotends().unionWith(std::declval&lt;IODrivers&lt;TupleT&gt; &gt;().heatedBeds()))" />
    </return>
  </method>
  <method id="iodrv::IODrivers::servos" name="servos">
    <brief>@return an iterable <ref ref="iodrv::IODrivers::iterinfo#iodrv::IODrivers::iterinfo">iodrv::IODrivers::iterinfo</ref> object that contains only the servo IODrivers</brief>
    <return>
      <type name="IODrivers&lt;TupleT&gt;::iterinfo&lt;Predicate&gt;" ref="iodrv::IODrivers::iterinfo#iodrv::IODrivers::iterinfo" />
    </return>
  </method>
  <method id="iodrv::IODrivers::endstops" name="endstops">
    <brief>@return an iterable <ref ref="iodrv::IODrivers::iterinfo#iodrv::IODrivers::iterinfo">iodrv::IODrivers::iterinfo</ref> object that contains only the endstop IODrivers</brief>
    <return>
      <type name="IODrivers&lt;TupleT&gt;::iterinfo&lt;Predicate&gt;" ref="iodrv::IODrivers::iterinfo#iodrv::IODrivers::iterinfo" />
    </return>
  </method>
  <method id="iodrv::IODrivers::lockAllAxes" name="lockAllAxes">
    <brief>apply T::lockAxis on each IODriver in the set</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
  </method>
  <method id="iodrv::IODrivers::unlockAllAxes" name="unlockAllAxes">
    <brief>apply T::unlockAxis on each IODriver in the set</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
  </method>
  <method id="iodrv::IODrivers::setHotendTemp" name="setHotendTemp">
    <brief>apply T::setTargetTemperature(temp) on each hotend in the set</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="iodrv::IODrivers::setHotendTemp::temp" name="temp">
      <type name="CelciusType" ref="index#CelciusType" />
    </argument>
  </method>
  <method id="iodrv::IODrivers::setBedTemp" name="setBedTemp">
    <brief>apply T::setTargetTemperature(temp) on each heated bed in the set</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="iodrv::IODrivers::setBedTemp::temp" name="temp">
      <type name="CelciusType" ref="index#CelciusType" />
    </argument>
  </method>
  <method id="iodrv::IODrivers::setFanDutyCycle" name="setFanDutyCycle">
    <brief>apply T::setFanDutyCycle(duty) on each fan in the set</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="iodrv::IODrivers::setFanDutyCycle::duty" name="duty">
      <type builtin="yes" name="float" />
    </argument>
  </method>
  <method id="iodrv::IODrivers::onIdleCpu" name="onIdleCpu">
    <brief>Call EVERY device's onIdleCpu handler, and return true if AT LEAST one of those handlers requests more time</brief>
    <doc>A request for more time is made by a specific IoDriver be returning true from its onIdleCpu handler.</doc>
    <return>
      <type builtin="yes" name="bool" />
    </return>
    <argument id="iodrv::IODrivers::onIdleCpu::interval" name="interval">
      <type name="OnIdleCpuIntervalT" ref="index#OnIdleCpuIntervalT" />
    </argument>
  </method>
  <method id="iodrv::IODrivers::peekNextEvent" name="peekNextEvent">
    <return>
      <type name="std::pair&lt;_T1, _T2&gt;" />
    </return>
  </method>
</classtemplate>
