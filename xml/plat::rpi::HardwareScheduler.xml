<?xml version='1.0' encoding='utf-8'?>
<class abstract="true" id="plat::rpi::HardwareScheduler" name="HardwareScheduler" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <doc>
implements the HardwareScheduler interface defined in platforms/generic/hardwarescheduler.h

It works by maintaining a circular queue of, say, 10 ms in length.
When it is told to toggle a pin at a specific time (via the 'queue' function), it edits this queue.
Meanwhile, a CPU peripheral called DMA (Direct Memory Access) is constantly each frame of this queue into the memory-mapped GPIO bank at a mostly constant rate.
This memory streaming happens constantly, regardless of what the CPU is doing. Logically, it's almost like an entirely separate entity from the cpu.

DMA timing is done by configuring the PWM module to request a sample at a given rate. Once this sample is requested, the entire DMA transaction is gated until the request is fulfilled. This allows one to copy a frame into the gpio bank and then fulfill the PWM sample request, which stalls the transaction until the PWM device requests another sample.

</doc>
  <constructor id="plat::rpi::HardwareScheduler::HardwareScheduler" name="HardwareScheduler" />
  <method id="plat::rpi::HardwareScheduler::cleanup" name="cleanup" static="yes">
    <return>
      <type builtin="yes" name="void" />
    </return>
  </method>
  <method id="plat::rpi::HardwareScheduler::onIdleCpu" name="onIdleCpu">
    <return>
      <type builtin="yes" name="bool" />
    </return>
    <argument id="plat::rpi::HardwareScheduler::onIdleCpu::interval" name="interval">
      <type name="OnIdleCpuIntervalT" ref="index#OnIdleCpuIntervalT" />
    </argument>
  </method>
  <method id="plat::rpi::HardwareScheduler::queue" name="queue">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="plat::rpi::HardwareScheduler::queue::evt" name="evt">
      <type name="OutputEvent" qualifier=" const &amp;" ref="OutputEvent#OutputEvent" />
    </argument>
  </method>
  <method id="plat::rpi::HardwareScheduler::queuePwm" name="queuePwm">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="plat::rpi::HardwareScheduler::queuePwm::pin" name="pin">
      <type name="PrimitiveIoPin" qualifier=" const &amp;" ref="plat::rpi::PrimitiveIoPin#plat::rpi::PrimitiveIoPin" />
    </argument>
    <argument id="plat::rpi::HardwareScheduler::queuePwm::ratio" name="ratio">
      <type builtin="yes" name="float" />
    </argument>
    <argument id="plat::rpi::HardwareScheduler::queuePwm::maxPeriod" name="maxPeriod">
      <type builtin="yes" name="float" />
    </argument>
  </method>
  <method id="plat::rpi::HardwareScheduler::schedTime" name="schedTime">
    <return>
      <type name="generic::ChronoClock::time_point" ref="plat::generic::ChronoClock#plat::generic::ChronoClock::time_point" />
    </return>
    <argument id="plat::rpi::HardwareScheduler::schedTime::evtTime" name="evtTime">
      <type name="generic::ChronoClock::time_point" ref="plat::generic::ChronoClock#plat::generic::ChronoClock::time_point" />
    </argument>
  </method>
</class>
