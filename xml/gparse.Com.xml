<?xml version='1.0' encoding='utf-8'?>
<class abstract="true" id="gparse::Com" name="Com" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <doc>
Com manages the low-level interfacing with whatever is controlling this printer.
reads are non-blocking, so tendCom() must be called on a regular basis.
once tendCom returns true, then a command is available via getCommand(), and a reply can be sent to the host via reply(...)

Communication is typically done over a serial interface, but Com accepts any file descriptor,
  so communication can be done via stdin (/dev/stdin) or commands can be directly fed from a gcode file.
</doc>
  <methodtemplate id="gparse::Com::giveFullOwnership" name="giveFullOwnership" static="yes">
    <brief>Whenever you pass a file pointer to the Com constructor, you must explicitly mark who the owner should be.</brief>
    <doc>If you wish to pass ownership over to Com, call Com(..., giveFullOwnership(file), ...)</doc>
    <return>
      <type name="ComStreamOwnershipMarker&lt;T&gt;" ref="gparse::ComStreamOwnershipMarker#gparse::ComStreamOwnershipMarker" />
    </return>
    <argument id="gparse::Com::giveFullOwnership::stream" name="stream">
      <type name="const T" qualifier=" const &amp;" />
    </argument>
    <templatetypeparameter id="gparse::Com::giveFullOwnership::T" name="T" />
  </methodtemplate>
  <methodtemplate id="gparse::Com::shareOwnership" name="shareOwnership" static="yes">
    <brief>Whenever you pass a file pointer to the Com constructor, you must explicitly mark who the owner should be.</brief>
    <doc>If you wish for the caller to retain ownership, call Com(..., shareOwnership(file), ...)</doc>
    <return>
      <type name="ComStreamOwnershipMarker&lt;T&gt;" ref="gparse::ComStreamOwnershipMarker#gparse::ComStreamOwnershipMarker" />
    </return>
    <argument id="gparse::Com::shareOwnership::stream" name="stream">
      <type name="const T" qualifier=" const &amp;" />
    </argument>
    <templatetypeparameter id="gparse::Com::shareOwnership::T" name="T" />
  </methodtemplate>
  <constructor id="gparse::Com::Com" name="Com">
    <brief>set @dieOnEof=true when reading from an actual, fix-length file, instead of a stream.</brief>
    <doc>useful when dealing with "subprograms" (printing from a file), in which the replies don't need to be sent back to the main com channel.
Com(const std::string &amp;fileR=NULL_FILE_STR, const std::string &amp;fileW=NULL_FILE_STR, bool dieOnEof=false);</doc>
    <argument id="gparse::Com::Com::readStream" name="readStream">
      <type name="ComStreamOwnershipMarker&lt;std::istream *&gt;" qualifier=" const &amp;" ref="gparse::ComStreamOwnershipMarker#gparse::ComStreamOwnershipMarker" />
    </argument>
    <argument id="gparse::Com::Com::writeStream" name="writeStream">
      <type name="ComStreamOwnershipMarker&lt;std::ostream *&gt;" qualifier=" const &amp;" ref="gparse::ComStreamOwnershipMarker#gparse::ComStreamOwnershipMarker" />
    </argument>
    <argument id="gparse::Com::Com::dieOnEof" name="dieOnEof">
      <type builtin="yes" name="bool" />
    </argument>
    <argument id="gparse::Com::Com::doSendGcodeComments" name="doSendGcodeComments">
      <type builtin="yes" name="bool" />
    </argument>
  </constructor>
  <method abstract="yes" id="gparse::Com::getCommand" name="getCommand">
    <brief>returns any pending command.</brief>
    <doc>sequential calls to getCommand() will all return the same command, until reply() is called, at which point the next command will be parsed.</doc>
    <return>
      <type name="Command" qualifier=" const &amp;" ref="gparse::Command#gparse::Command" />
    </return>
  </method>
  <method abstract="yes" id="gparse::Com::hasReadFile" name="hasReadFile">
    <return>
      <type builtin="yes" name="bool" />
    </return>
  </method>
  <method abstract="yes" id="gparse::Com::hasWriteFile" name="hasWriteFile">
    <return>
      <type builtin="yes" name="bool" />
    </return>
  </method>
  <method abstract="yes" id="gparse::Com::isAtEof" name="isAtEof">
    <brief>if reading with dieOnEof=true, and the last command has been parsed (but not necessarily responded to),</brief>
    <doc>then this function will return true</doc>
    <return>
      <type builtin="yes" name="bool" />
    </return>
  </method>
  <method abstract="yes" id="gparse::Com::reply" name="reply">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="gparse::Com::reply::resp" name="resp">
      <type name="Response" qualifier=" const &amp;" ref="gparse::Response#gparse::Response" />
    </argument>
  </method>
  <method abstract="yes" id="gparse::Com::tendCom" name="tendCom">
    <brief>returns true if there is a command ready to be interpreted.</brief>
    <return>
      <type builtin="yes" name="bool" />
    </return>
  </method>
</class>
