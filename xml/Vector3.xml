<?xml version='1.0' encoding='utf-8'?>
<classtemplate id="Vector3" name="Vector3" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <brief>mathematical vector utility</brief>
  <templatetypeparameter id="Vector3::F" name="F" />
  <constructor id="Vector3::Vector3&lt;F&gt;" name="Vector3&lt;F&gt;">
    <brief>default initialize: all components are zeroed</brief>
  </constructor>
  <constructor id="Vector3::Vector3&lt;F&gt;" name="Vector3&lt;F&gt;">
    <brief>initialize from components</brief>
    <argument id="Vector3::Vector3&lt;F&gt;::x" name="x">
      <type name="F" />
    </argument>
    <argument id="Vector3::Vector3&lt;F&gt;::y" name="y">
      <type name="F" />
    </argument>
    <argument id="Vector3::Vector3&lt;F&gt;::z" name="z">
      <type name="F" />
    </argument>
  </constructor>
  <methodtemplate id="Vector3::Vector3&lt;F&gt;" name="Vector3&lt;F&gt;">
    <brief>initialize from another Vector3, possibly of a different precision</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="Vector3::Vector3&lt;F&gt;::v" name="v">
      <type name="Vector3&lt;F&gt;" qualifier=" const &amp;" ref="Vector3#Vector3" />
    </argument>
    <templatetypeparameter id="Vector3::Vector3&lt;F&gt;::T2" name="T2" />
  </methodtemplate>
  <method id="Vector3::tuple" name="tuple">
    <brief>cast to a tuple of &amp;lt;x, y, z&amp;gt;</brief>
    <return>
      <type name="std::tuple&lt;_Elements&gt;" />
    </return>
  </method>
  <conversionfunction id="Vector3::operator tuple&lt;type-parameter-0-0, type-parameter-0-0, type-parameter-0-0&gt;" name="operator tuple&lt;type-parameter-0-0, type-parameter-0-0, type-parameter-0-0&gt;">
    <brief>cast to a tuple of &amp;lt;x, y, z&amp;gt;</brief>
    <return>
      <type name="std::tuple&lt;_Elements&gt;" />
    </return>
  </conversionfunction>
  <method id="Vector3::array" name="array">
    <brief>cast to a std::array of &amp;lt;x, y, z&amp;gt;</brief>
    <return>
      <type name="std::array&lt;_Tp, _Nm&gt;" />
    </return>
  </method>
  <conversionfunction id="Vector3::operator array&lt;type-parameter-0-0, 3&gt;" name="operator array&lt;type-parameter-0-0, 3&gt;">
    <brief>cast to a std::array of &amp;lt;x, y, z&amp;gt;</brief>
    <return>
      <type name="std::array&lt;_Tp, _Nm&gt;" />
    </return>
  </conversionfunction>
  <method id="Vector3::str" name="str">
    <brief>string representation: "Vector3(x, y, z)"</brief>
    <return>
      <type name="std::string" />
    </return>
  </method>
  <conversionfunction id="Vector3::operator basic_string" name="operator basic_string">
    <brief>string representation: "Vector3(x, y, z)"</brief>
    <return>
      <type name="std::string" />
    </return>
  </conversionfunction>
  <method id="Vector3::x" name="x">
    <brief>@return x component</brief>
    <return>
      <type name="F" />
    </return>
  </method>
  <method id="Vector3::y" name="y">
    <brief>@return y component</brief>
    <return>
      <type name="F" />
    </return>
  </method>
  <method id="Vector3::z" name="z">
    <brief>@return z component</brief>
    <return>
      <type name="F" />
    </return>
  </method>
  <method id="Vector3::magSq" name="magSq">
    <brief>@return the square of the magnitude (length) of the vector.</brief>
    <doc>equivalent to this-&gt;mag() * this-&gt;mag(), but less verbose and explicitly avoids the sqrt operation.</doc>
    <return>
      <type name="F" />
    </return>
  </method>
  <method id="Vector3::mag" name="mag">
    <brief>@return magnitude (length) of the vector</brief>
    <return>
      <type name="F" />
    </return>
  </method>
  <method id="Vector3::withX" name="withX">
    <brief>@return the equivalent vector, but with @_x=@x</brief>
    <return>
      <type name="Vector3&lt;F&gt;" ref="Vector3#Vector3" />
    </return>
    <argument id="Vector3::withX::x" name="x">
      <type name="F" />
    </argument>
  </method>
  <method id="Vector3::withY" name="withY">
    <brief>@return the equivalent vector, but with @_y=@y</brief>
    <return>
      <type name="Vector3&lt;F&gt;" ref="Vector3#Vector3" />
    </return>
    <argument id="Vector3::withY::y" name="y">
      <type name="F" />
    </argument>
  </method>
  <method id="Vector3::withZ" name="withZ">
    <brief>@return the equivalent vector, but with @_y=@y</brief>
    <return>
      <type name="Vector3&lt;F&gt;" ref="Vector3#Vector3" />
    </return>
    <argument id="Vector3::withZ::z" name="z">
      <type name="F" />
    </argument>
  </method>
  <method id="Vector3::operator-" name="operator-">
    <brief>unary negation operator (x = -y)</brief>
    <return>
      <type name="Vector3&lt;F&gt;" ref="Vector3#Vector3" />
    </return>
  </method>
  <method id="Vector3::norm" name="norm">
    <brief>Normalize the vector</brief>
    <return>
      <type name="Vector3&lt;F&gt;" ref="Vector3#Vector3" />
    </return>
  </method>
  <method id="Vector3::operator+" name="operator+">
    <brief>operators:</brief>
    <return>
      <type name="Vector3&lt;F&gt;" ref="Vector3#Vector3" />
    </return>
    <argument id="Vector3::operator+::v" name="v">
      <type name="Vector3&lt;F&gt;" qualifier=" const &amp;" ref="Vector3#Vector3" />
    </argument>
  </method>
  <method id="Vector3::operator+=" name="operator+=">
    <return>
      <type name="Vector3&lt;F&gt;" qualifier=" &amp;" ref="Vector3#Vector3" />
    </return>
    <argument id="Vector3::operator+=::v" name="v">
      <type name="Vector3&lt;F&gt;" qualifier=" const &amp;" ref="Vector3#Vector3" />
    </argument>
  </method>
  <method id="Vector3::operator-" name="operator-">
    <return>
      <type name="Vector3&lt;F&gt;" ref="Vector3#Vector3" />
    </return>
    <argument id="Vector3::operator-::v" name="v">
      <type name="Vector3&lt;F&gt;" qualifier=" const &amp;" ref="Vector3#Vector3" />
    </argument>
  </method>
  <method id="Vector3::operator-=" name="operator-=">
    <return>
      <type name="Vector3&lt;F&gt;" qualifier=" &amp;" ref="Vector3#Vector3" />
    </return>
    <argument id="Vector3::operator-=::v" name="v">
      <type name="Vector3&lt;F&gt;" qualifier=" const &amp;" ref="Vector3#Vector3" />
    </argument>
  </method>
  <method id="Vector3::operator*" name="operator*">
    <return>
      <type name="Vector3&lt;F&gt;" ref="Vector3#Vector3" />
    </return>
    <argument id="Vector3::operator*::s" name="s">
      <type name="F" />
    </argument>
  </method>
  <method id="Vector3::operator*=" name="operator*=">
    <return>
      <type name="Vector3&lt;F&gt;" qualifier=" &amp;" ref="Vector3#Vector3" />
    </return>
    <argument id="Vector3::operator*=::s" name="s">
      <type name="F" />
    </argument>
  </method>
  <method id="Vector3::operator/" name="operator/">
    <return>
      <type name="Vector3&lt;F&gt;" ref="Vector3#Vector3" />
    </return>
    <argument id="Vector3::operator/::s" name="s">
      <type name="F" />
    </argument>
  </method>
  <method id="Vector3::operator/=" name="operator/=">
    <return>
      <type name="Vector3&lt;F&gt;" qualifier=" &amp;" ref="Vector3#Vector3" />
    </return>
    <argument id="Vector3::operator/=::s" name="s">
      <type name="F" />
    </argument>
  </method>
  <method id="Vector3::dot" name="dot">
    <brief>The vector dot product: this . v</brief>
    <return>
      <type name="F" />
    </return>
    <argument id="Vector3::dot::v" name="v">
      <type name="Vector3&lt;F&gt;" qualifier=" const &amp;" ref="Vector3#Vector3" />
    </argument>
  </method>
  <method id="Vector3::cross" name="cross">
    <brief>The vector cross product: this x v</brief>
    <doc>|   i   j   k   |
|   ux  uy  uz  |
|   vx  vy  vz  |
= &amp;lt;uy\*vz - uz\*vy, uz\*vx - ux\*vz, ux\*vy - uy\*vx&amp;gt;</doc>
    <return>
      <type name="Vector3&lt;F&gt;" ref="Vector3#Vector3" />
    </return>
    <argument id="Vector3::cross::v" name="v">
      <type name="Vector3&lt;F&gt;" qualifier=" const &amp;" ref="Vector3#Vector3" />
    </argument>
  </method>
  <method id="Vector3::scalarProj" name="scalarProj">
    <brief>The scalar projection of `this' onto v.</brief>
    <doc>That is, the scalar component of `this' in the direction of v.</doc>
    <return>
      <type name="F" />
    </return>
    <argument id="Vector3::scalarProj::v" name="v">
      <type name="Vector3&lt;F&gt;" qualifier=" const &amp;" ref="Vector3#Vector3" />
    </argument>
  </method>
  <method id="Vector3::proj" name="proj">
    <brief>projection of `this' onto v.</brief>
    <doc>That is, the vector componenent of `this' in the direction of v.
This is equivalent to (this-&gt;scalarProj(v)) * v.norm(),
but we explicitly avoid the sqrt operations</doc>
    <return>
      <type name="Vector3&lt;F&gt;" ref="Vector3#Vector3" />
    </return>
    <argument id="Vector3::proj::v" name="v">
      <type name="Vector3&lt;F&gt;" qualifier=" const &amp;" ref="Vector3#Vector3" />
    </argument>
  </method>
  <method id="Vector3::distance" name="distance">
    <brief>@return the distance from @this to @v</brief>
    <return>
      <type name="F" />
    </return>
    <argument id="Vector3::distance::v" name="v">
      <type name="Vector3&lt;F&gt;" qualifier=" const &amp;" ref="Vector3#Vector3" />
    </argument>
  </method>
  <method id="Vector3::distance" name="distance">
    <brief>@return the distance from @this to the point indicated by (@x, @y, @z)</brief>
    <return>
      <type name="F" />
    </return>
    <argument id="Vector3::distance::x" name="x">
      <type name="F" />
    </argument>
    <argument id="Vector3::distance::y" name="y">
      <type name="F" />
    </argument>
    <argument id="Vector3::distance::z" name="z">
      <type name="F" />
    </argument>
  </method>
</classtemplate>
