<?xml version='1.0' encoding='utf-8'?>
<classtemplate id="motion::MotionPlanner" name="MotionPlanner" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <doc>
MotionPlanner takes commands from the State (mainly those caused by G1 and G28) and resolves the move into a path via interfacing with a CoordMap, AxisSteppers, and an AccelerationProfile.
Once a path is planned, State can call MotionPlanner.nextStep() and be given data in the form of an Event, which can be passed on to a Scheduler.

@Interface must have 2 public typedefs: CoordMapT and AccelerationProfileT. These are often provided by the machine driver.
</doc>
  <templatetypeparameter id="motion::MotionPlanner::Interface" name="Interface" />
  <constructor id="motion::MotionPlanner::MotionPlanner&lt;Interface&gt;" name="MotionPlanner&lt;Interface&gt;">
    <argument id="motion::MotionPlanner::MotionPlanner&lt;Interface&gt;::interface" name="interface">
      <type name="const Interface" qualifier=" const &amp;" />
    </argument>
  </constructor>
  <method id="motion::MotionPlanner::coordMap" name="coordMap">
    <return>
      <type name="MotionPlanner&lt;Interface&gt;::CoordMapT" qualifier=" const &amp;" ref="motion::MotionPlanner#motion::MotionPlanner::CoordMapT" />
    </return>
  </method>
  <method id="motion::MotionPlanner::coordMap" name="coordMap">
    <return>
      <type name="MotionPlanner&lt;Interface&gt;::CoordMapT" qualifier=" &amp;" ref="motion::MotionPlanner#motion::MotionPlanner::CoordMapT" />
    </return>
  </method>
  <method id="motion::MotionPlanner::readyForNextMove" name="readyForNextMove">
    <brief>readForNextMove returns true if a call to moveTo() or homeEndstops() wouldn't hang, false if it would hang (or cause other problems)</brief>
    <return>
      <type builtin="yes" name="bool" />
    </return>
  </method>
  <method id="motion::MotionPlanner::doHomeBeforeFirstMovement" name="doHomeBeforeFirstMovement">
    <return>
      <type builtin="yes" name="bool" />
    </return>
  </method>
  <method id="motion::MotionPlanner::actualCartesianPosition" name="actualCartesianPosition">
    <brief>return the actual cartesian position of the effector/hotend</brief>
    <doc>Note that if there is a move in progress, this position is based off the last step event
that's been retrieved from &amp;lt;nextOutputEvent&amp;gt;</doc>
    <return>
      <type name="Vector4f" ref="index#Vector4f" />
    </return>
  </method>
  <method id="motion::MotionPlanner::axisPositions" name="axisPositions">
    <return>
      <type name="std::array&lt;_Tp, _Nm&gt;" qualifier=" const &amp;" />
    </return>
  </method>
  <method id="motion::MotionPlanner::resetAxisPositions" name="resetAxisPositions">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="motion::MotionPlanner::resetAxisPositions::pos" name="pos">
      <type name="std::array&lt;_Tp, _Nm&gt;" qualifier=" const &amp;" />
    </argument>
  </method>
  <method id="motion::MotionPlanner::peekNextEvent" name="peekNextEvent">
    <return>
      <type name="OutputEvent" ref="OutputEvent#OutputEvent" />
    </return>
  </method>
  <method id="motion::MotionPlanner::consumeNextEvent" name="consumeNextEvent">
    <return>
      <type builtin="yes" name="void" />
    </return>
  </method>
  <method id="motion::MotionPlanner::moveTo" name="moveTo">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="motion::MotionPlanner::moveTo::baseTime" name="baseTime">
      <type name="plat::generic::ChronoClock::time_point" ref="plat::generic::ChronoClock#plat::generic::ChronoClock::time_point" />
    </argument>
    <argument id="motion::MotionPlanner::moveTo::dest_" name="dest_">
      <type name="Vector4f" qualifier=" const &amp;" ref="index#Vector4f" />
    </argument>
    <argument id="motion::MotionPlanner::moveTo::maxVelXyz" name="maxVelXyz">
      <type builtin="yes" name="float" />
    </argument>
    <argument id="motion::MotionPlanner::moveTo::minVelE" name="minVelE">
      <type builtin="yes" name="float" />
    </argument>
    <argument id="motion::MotionPlanner::moveTo::maxVelE" name="maxVelE">
      <type builtin="yes" name="float" />
    </argument>
    <argument id="motion::MotionPlanner::moveTo::flags" name="flags">
      <type name="MotionFlags" ref="motion#motion::MotionFlags" />
    </argument>
  </method>
  <method id="motion::MotionPlanner::arcTo" name="arcTo">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="motion::MotionPlanner::arcTo::baseTime" name="baseTime">
      <type name="plat::generic::ChronoClock::time_point" ref="plat::generic::ChronoClock#plat::generic::ChronoClock::time_point" />
    </argument>
    <argument id="motion::MotionPlanner::arcTo::dest_" name="dest_">
      <type name="Vector4f" qualifier=" const &amp;" ref="index#Vector4f" />
    </argument>
    <argument id="motion::MotionPlanner::arcTo::center_" name="center_">
      <type name="Vector3f" qualifier=" const &amp;" ref="index#Vector3f" />
    </argument>
    <argument id="motion::MotionPlanner::arcTo::maxVelXyz" name="maxVelXyz">
      <type builtin="yes" name="float" />
    </argument>
    <argument id="motion::MotionPlanner::arcTo::minVelE" name="minVelE">
      <type builtin="yes" name="float" />
    </argument>
    <argument id="motion::MotionPlanner::arcTo::maxVelE" name="maxVelE">
      <type builtin="yes" name="float" />
    </argument>
    <argument id="motion::MotionPlanner::arcTo::isCW" name="isCW">
      <type builtin="yes" name="bool" />
    </argument>
    <argument id="motion::MotionPlanner::arcTo::flags" name="flags">
      <type name="MotionFlags" ref="motion#motion::MotionFlags" />
    </argument>
  </method>
</classtemplate>
