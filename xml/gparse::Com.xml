<?xml version='1.0' encoding='utf-8'?>
<class id="gparse::Com" name="Com" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <doc>
Com manages the low-level interfacing with whatever is controlling this printer.
reads are non-blocking, so tendCom() must be called on a regular basis.
once tendCom returns true, then a command is available via getCommand(), and a reply can be sent to the host via reply(...)

Communication is typically done over a serial interface, but Com accepts any file descriptor,
  so communication can be done via stdin (/dev/stdin) or commands can be directly fed from a gcode file.
</doc>
  <variable id="gparse::Com::NULL_FILE_STR" name="NULL_FILE_STR">
    <brief>initialize static consts:</brief>
    <type name="std::string" qualifier=" const" />
  </variable>
  <constructor id="gparse::Com::Com" name="Com" />
  <constructor id="gparse::Com::Com" name="Com">
    <brief>set @dieOnEof=true when reading from an actual, fix-length file, instead of a stream.</brief>
    <doc>useful when dealing with "subprograms" (printing from a file), in which the replies don't need to be sent back to the main com channel.</doc>
    <argument id="gparse::Com::Com::fileR" name="fileR">
      <type name="std::string" qualifier=" const &amp;" />
    </argument>
    <argument id="gparse::Com::Com::fileW" name="fileW">
      <type name="std::string" qualifier=" const &amp;" />
    </argument>
    <argument id="gparse::Com::Com::dieOnEof" name="dieOnEof">
      <type builtin="yes" name="bool" />
    </argument>
  </constructor>
  <method id="gparse::Com::getCommand" name="getCommand">
    <brief>returns any pending command.</brief>
    <doc>sequential calls to getCommand() will all return the same command, until reply() is called, at which point the next command will be parsed.</doc>
    <return>
      <type name="Command" qualifier=" const &amp;" ref="gparse::Command#gparse::Command" />
    </return>
  </method>
  <method id="gparse::Com::hasReadFile" name="hasReadFile">
    <return>
      <type builtin="yes" name="bool" />
    </return>
  </method>
  <method id="gparse::Com::hasWriteFile" name="hasWriteFile">
    <return>
      <type builtin="yes" name="bool" />
    </return>
  </method>
  <method id="gparse::Com::isAtEof" name="isAtEof">
    <brief>if reading with dieOnEof=true, and the last command has been parsed (but not necessarily responded to),</brief>
    <doc>then this function will return true</doc>
    <return>
      <type builtin="yes" name="bool" />
    </return>
  </method>
  <method id="gparse::Com::reply" name="reply">
    <brief>void reply(const std::string &amp;resp);</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="gparse::Com::reply::resp" name="resp">
      <type name="Response" qualifier=" const &amp;" ref="gparse::Response#gparse::Response" />
    </argument>
  </method>
  <method id="gparse::Com::tendCom" name="tendCom">
    <brief>returns true if there is a command ready to be interpreted.</brief>
    <return>
      <type builtin="yes" name="bool" />
    </return>
  </method>
</class>
