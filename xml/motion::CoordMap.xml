<?xml version='1.0' encoding='utf-8'?>
<class id="motion::CoordMap" name="CoordMap" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <doc>
CoordMaps are used to translate cartesian coordinates to and from the machine's coordinate system
This allows for a bot to internally use a non-cartesian coordinate system - very useful for delta bots.

Note: CoordMap is an interface, and not an implementation.
An implementation is needed for each coordinate style - Cartesian, deltabot, etc.
These implementations must provide the functions outlined further down in the header.

Note: the term "axis coordinates" refers to an individual motor's microstep index (no wraparound).
  whereas "cartesian coordinates" refers to the print head's location in [x, y, z[, e]] space in units of mm.
  For example, if your Z motor has 1000 steps/mm and is 200 mm tall, then an axis coordinate of 0 translates to a cartesian Z coordinate of 0mm,
    and an axis coordinate of 200000 translates to a cartesian Z coordinate of 200mm.
</doc>
  <subclass access="public" name="LinearCoordMap" ref="motion::LinearCoordMap#motion::LinearCoordMap" />
  <subclass access="public" name="LinearDeltaCoordMap" ref="motion::LinearDeltaCoordMap#motion::LinearDeltaCoordMap" />
  <methodtemplate id="motion::CoordMap::executeHomeRoutine" name="executeHomeRoutine">
    <brief>Home the machine by sending commands to @interface</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="motion::CoordMap::executeHomeRoutine::interface" name="interface">
      <type name="Interface" qualifier=" &amp;" />
    </argument>
    <templatetypeparameter id="motion::CoordMap::executeHomeRoutine::Interface" name="Interface" />
  </methodtemplate>
  <method id="motion::CoordMap::applyLeveling" name="applyLeveling">
    <brief>apply some leveling transformation to the [x,y,z] cartesian coordinate to compensate for an unlevel bed.</brief>
    <doc>Note: this is only applied to the endpoints of a line, so a non-planar bed cannot properly be leveled.</doc>
    <return>
      <type name="Vector3f" ref="index#Vector3f" />
    </return>
    <argument id="motion::CoordMap::applyLeveling::xyz" name="xyz">
      <type name="Vector3f" qualifier=" const &amp;" ref="index#Vector3f" />
    </argument>
  </method>
  <method id="motion::CoordMap::bound" name="bound">
    <brief>ensure that the desired coordinate is accessible. (i.e. motors won't ram the endstops, etc).</brief>
    <return>
      <type name="Vector4f" ref="index#Vector4f" />
    </return>
    <argument id="motion::CoordMap::bound::xyze" name="xyze">
      <type name="Vector4f" qualifier=" const &amp;" ref="index#Vector4f" />
    </argument>
  </method>
  <method id="motion::CoordMap::doHomeBeforeFirstMovement" name="doHomeBeforeFirstMovement">
    <brief>if we get a G1 before the first G28, then we *probably* want to home first,</brief>
    <doc>but feel free to override this in other implementations.</doc>
    <return>
      <type builtin="yes" name="bool" />
    </return>
  </method>
  <method id="motion::CoordMap::getAxisSteppers" name="getAxisSteppers">
    <return>
      <type name="std::tuple&lt;&gt;" />
    </return>
  </method>
  <method id="motion::CoordMap::getDependentIoDrivers" name="getDependentIoDrivers">
    <brief>If the coordmap internally contains IoDrivers (e.g. stepper drivers or servos to lower the probe), then it should return a tuple of REFERENCES to them.</brief>
    <return>
      <type name="std::tuple&lt;&gt;" />
    </return>
  </method>
  <method id="motion::CoordMap::getEndstop" name="getEndstop">
    <brief>return a reference to the Endstop associated with a given axis (eg X-endstop, Y-endstop, etc)</brief>
    <doc>Depending on which AxisSteppers your CoordMap uses, you may not need to implement this function.</doc>
    <return>
      <type name="iodrv::Endstop" qualifier=" const &amp;" ref="iodrv::Endstop#iodrv::Endstop" />
    </return>
    <argument id="motion::CoordMap::getEndstop::axis" name="axis">
      <type name="std::size_t" />
    </argument>
  </method>
  <method id="motion::CoordMap::getHomePosition" name="getHomePosition">
    <brief>given the current tracked motor coordinates, and knowing that we are at home position,</brief>
    <return>
      <type name="std::array&lt;int, 0&gt;" />
    </return>
    <argument id="motion::CoordMap::getHomePosition::cur" name="cur">
      <type name="std::array&lt;int, 0&gt;" qualifier=" const &amp;" />
    </argument>
  </method>
  <method id="motion::CoordMap::numAxis" name="numAxis" static="yes">
    <brief>return the number of axis (physical motors) that we have.</brief>
    <return>
      <type name="std::size_t" />
    </return>
  </method>
  <method id="motion::CoordMap::xyzeFromMechanical" name="xyzeFromMechanical">
    <brief>given axis coordinates &amp;mech, calculate the cartesian [x,y,z,e] coordinates that the printhead is at.</brief>
    <return>
      <type name="Vector4f" ref="index#Vector4f" />
    </return>
    <argument id="motion::CoordMap::xyzeFromMechanical::mech" name="mech">
      <type name="std::array&lt;int, 0&gt;" qualifier=" const &amp;" />
    </argument>
  </method>
</class>
