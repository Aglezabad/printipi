<?xml version='1.0' encoding='utf-8'?>
<classtemplate id="State" name="State" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <doc>
State handles as much driver-mutual functionality as possible, including mapping Gcodes to specific functions,
  tracking unit mode and axis position, and interfacing with the scheduler.
State controls the communications channel, the scheduler, and the underlying driver.
Motion planning is offloaded to src/motion/MotionPlanner
</doc>
  <templatetypeparameter id="State::Drv" name="Drv" />
  <constructor id="State::State&lt;Drv&gt;" name="State&lt;Drv&gt;">
    <brief>Initialize the state:</brief>
    <argument id="State::State&lt;Drv&gt;::drv" name="drv">
      <doc>Machine instance to take ownership of</doc>
      <type name="Drv &amp;&amp;" />
    </argument>
    <argument id="State::State&lt;Drv&gt;::fs" name="fs">
      <doc>FileSystem object that describes where to look when asked to open a gcode file</doc>
      <type name="FileSystem" qualifier=" const &amp;" ref="FileSystem#FileSystem" />
    </argument>
    <argument id="State::State&lt;Drv&gt;::needPersistentCom" name="needPersistentCom">
      <doc>flag to always keep the first communication channel (e.g. stdio) open
M32 command allows branching to another, local gcode file. By default, this will PAUSE reading/writing from the previous com channel.
But if we want to continue reading from that original com channel while simultaneously reading from the new gcode file, then 'needPersistentCom' should be set to true.
This is normally only relevant for communication with a host, like Octoprint, where we want temperature reading, emergency stop, etc to still work.</doc>
      <type builtin="yes" name="bool" />
    </argument>
  </constructor>
  <method id="State::eventLoop" name="eventLoop">
    <brief>Continually service communication channels &amp; execute received commands until we receive a command to exit</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
  </method>
  <method id="State::motionPlanner" name="motionPlanner">
    <brief>return a read-only reference to the interal MotionPlanner object</brief>
    <doc>Useful only for introspection (e.g. when running automated tests)</doc>
    <return>
      <type name="motion::MotionPlanner&lt;Interface&gt;" qualifier=" const &amp;" ref="motion::MotionPlanner#motion::MotionPlanner" />
    </return>
  </method>
  <method id="State::setPersistentHostCom" name="setPersistentHostCom">
    <brief>if set to false, then running a subprogram will cause the main communication channel to not be serviced until the subprogram returns</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="State::setPersistentHostCom::persistence" name="persistence">
      <type builtin="yes" name="bool" />
    </argument>
  </method>
  <method id="State::addComChannel" name="addComChannel">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="State::addComChannel::ch" name="ch">
      <type name="gparse::Com &amp;&amp;" />
    </argument>
  </method>
  <constructor id="State::State&lt;Drv&gt;" name="State&lt;Drv&gt;">
    <argument id="State::State&lt;Drv&gt;::drv" name="drv">
      <type name="Drv &amp;&amp;" />
    </argument>
    <argument id="State::State&lt;Drv&gt;::fs" name="fs">
      <type name="FileSystem" qualifier=" const &amp;" ref="FileSystem#FileSystem" />
    </argument>
    <argument id="State::State&lt;Drv&gt;::needPersistentCom" name="needPersistentCom">
      <type builtin="yes" name="bool" />
    </argument>
  </constructor>
  <method id="State::setMoveBuffering" name="setMoveBuffering">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="State::setMoveBuffering::doBufferMoves" name="doBufferMoves">
      <type builtin="yes" name="bool" />
    </argument>
  </method>
  <method id="State::positionMode" name="positionMode">
    <return>
      <type name="PositionMode" ref="index#PositionMode" />
    </return>
  </method>
  <method id="State::setPositionMode" name="setPositionMode">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="State::setPositionMode::mode" name="mode">
      <type name="PositionMode" ref="index#PositionMode" />
    </argument>
  </method>
  <method id="State::extruderPosMode" name="extruderPosMode">
    <return>
      <type name="PositionMode" ref="index#PositionMode" />
    </return>
  </method>
  <method id="State::setExtruderPosMode" name="setExtruderPosMode">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="State::setExtruderPosMode::mode" name="mode">
      <type name="PositionMode" ref="index#PositionMode" />
    </argument>
  </method>
  <method id="State::setUnitMode" name="setUnitMode">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="State::setUnitMode::mode" name="mode">
      <type name="LengthUnit" ref="index#LengthUnit" />
    </argument>
  </method>
  <method id="State::coordToAbsolute" name="coordToAbsolute">
    <return>
      <type name="Vector4f" ref="index#Vector4f" />
    </return>
    <argument id="State::coordToAbsolute::posUnit" name="posUnit">
      <type name="Vector4f" qualifier=" const &amp;" ref="index#Vector4f" />
    </argument>
  </method>
  <method id="State::coordToMm" name="coordToMm">
    <return>
      <type name="Vector4f" ref="index#Vector4f" />
    </return>
    <argument id="State::coordToMm::coord" name="coord">
      <type name="Vector4f" qualifier=" const &amp;" ref="index#Vector4f" />
    </argument>
  </method>
  <method id="State::coordToPrimitive" name="coordToPrimitive">
    <return>
      <type name="Vector4f" ref="index#Vector4f" />
    </return>
    <argument id="State::coordToPrimitive::coord" name="coord">
      <type name="Vector4f" qualifier=" const &amp;" ref="index#Vector4f" />
    </argument>
  </method>
  <method id="State::fUnitToPrimitive" name="fUnitToPrimitive">
    <return>
      <type builtin="yes" name="float" />
    </return>
    <argument id="State::fUnitToPrimitive::posUnit" name="posUnit">
      <type builtin="yes" name="float" />
    </argument>
  </method>
  <method id="State::destMm" name="destMm">
    <return>
      <type name="Vector4f" ref="index#Vector4f" />
    </return>
  </method>
  <method id="State::destMoveRatePrimitive" name="destMoveRatePrimitive">
    <return>
      <type builtin="yes" name="float" />
    </return>
  </method>
  <method id="State::setDestMoveRatePrimitive" name="setDestMoveRatePrimitive">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="State::setDestMoveRatePrimitive::f" name="f">
      <type builtin="yes" name="float" />
    </argument>
  </method>
  <method id="State::setHostZeroPos" name="setHostZeroPos">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="State::setHostZeroPos::x" name="x">
      <type builtin="yes" name="float" />
    </argument>
    <argument id="State::setHostZeroPos::y" name="y">
      <type builtin="yes" name="float" />
    </argument>
    <argument id="State::setHostZeroPos::z" name="z">
      <type builtin="yes" name="float" />
    </argument>
    <argument id="State::setHostZeroPos::e" name="e">
      <type builtin="yes" name="float" />
    </argument>
  </method>
  <method id="State::onIdleCpu" name="onIdleCpu">
    <return>
      <type builtin="yes" name="bool" />
    </return>
    <argument id="State::onIdleCpu::interval" name="interval">
      <type name="OnIdleCpuIntervalT" ref="index#OnIdleCpuIntervalT" />
    </argument>
  </method>
  <method id="State::eventLoop" name="eventLoop">
    <return>
      <type builtin="yes" name="void" />
    </return>
  </method>
  <method id="State::tendComChannel" name="tendComChannel">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="State::tendComChannel::com" name="com">
      <type name="gparse::Com" qualifier=" &amp;" ref="gparse::Com#gparse::Com" />
    </argument>
  </method>
  <methodtemplate id="State::execute" name="execute">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="State::execute::cmd" name="cmd">
      <type name="gparse::Command" qualifier=" const &amp;" ref="gparse::Command#gparse::Command" />
    </argument>
    <argument id="State::execute::reply" name="reply">
      <type name="ReplyFunc" />
    </argument>
    <templatetypeparameter id="State::execute::ReplyFunc" name="ReplyFunc" />
  </methodtemplate>
  <method id="State::queueArc" name="queueArc">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="State::queueArc::dest" name="dest">
      <type name="Vector4f" qualifier=" const &amp;" ref="index#Vector4f" />
    </argument>
    <argument id="State::queueArc::center" name="center">
      <type name="Vector3f" qualifier=" const &amp;" ref="index#Vector3f" />
    </argument>
    <argument id="State::queueArc::isCW" name="isCW">
      <type builtin="yes" name="bool" />
    </argument>
  </method>
  <method id="State::queueMovement" name="queueMovement">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="State::queueMovement::dest" name="dest">
      <type name="Vector4f" qualifier=" const &amp;" ref="index#Vector4f" />
    </argument>
    <argument id="State::queueMovement::velXyz" name="velXyz">
      <type name="OptionalArg&lt;float&gt;" />
    </argument>
    <argument id="State::queueMovement::flags" name="flags">
      <type name="motion::MotionFlags" qualifier=" const" ref="motion#motion::MotionFlags" />
    </argument>
  </method>
  <method id="State::homeEndstops" name="homeEndstops">
    <return>
      <type builtin="yes" name="void" />
    </return>
  </method>
  <method id="State::areHeatersReady" name="areHeatersReady">
    <return>
      <type builtin="yes" name="bool" />
    </return>
  </method>
  <method id="State::getEndstopStatusString" name="getEndstopStatusString">
    <return>
      <type name="std::string" />
    </return>
  </method>
</classtemplate>
