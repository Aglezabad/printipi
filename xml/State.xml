<?xml version='1.0' encoding='utf-8'?>
<classtemplate id="State" name="State" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <doc>
State handles as much driver-mutual functionality as possible, including mapping Gcodes to specific functions,
  tracking unit mode and axis position, and interfacing with the scheduler.
State controls the communications channel, the scheduler, and the underlying driver.
Motion planning is offloaded to src/motion/MotionPlanner
</doc>
  <templatetypeparameter id="State::Drv" name="Drv" />
  <constructor id="State::State&lt;Drv&gt;" name="State&lt;Drv&gt;">
    <brief>Initialize the state:</brief>
    <doc>Needs a driver object (drv), a communications channel (com), and needs to know whether or not the com channel must be persistent
M32 command allows branching to another, local gcode file. By default, this will PAUSE reading/writing from the previous com channel.
But if we want to continue reading from that original com channel while simultaneously reading from the new gcode file, then 'needPersistentCom' should be set to true.
This is normally only relevant for communication with a host, like Octoprint, where we want temperature reading, emergency stop, etc to still work.</doc>
    <argument id="State::State&lt;Drv&gt;::drv" name="drv">
      <type name="Drv &amp;&amp;" />
    </argument>
    <argument id="State::State&lt;Drv&gt;::fs" name="fs">
      <type name="FileSystem" qualifier=" const &amp;" ref="FileSystem#FileSystem" />
    </argument>
    <argument id="State::State&lt;Drv&gt;::needPersistentCom" name="needPersistentCom">
      <type builtin="yes" name="bool" />
    </argument>
  </constructor>
  <method id="State::eventLoop" name="eventLoop">
    <brief>Continually service communication channels &amp; execute received commands until we receive a command to exit</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
  </method>
  <method id="State::motionPlanner" name="motionPlanner">
    <brief>return a read-only reference to the interal MotionPlanner object</brief>
    <doc>Useful only for introspection (e.g. when running automated tests)</doc>
    <return>
      <type name="motion::MotionPlanner&lt;Interface&gt;" qualifier=" const &amp;" ref="motion::MotionPlanner#motion::MotionPlanner" />
    </return>
  </method>
  <method id="State::setPersistentHostCom" name="setPersistentHostCom">
    <brief>if set to false, then running a subprogram will cause the main communication channel to not be serviced until the subprogram returns</brief>
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="State::setPersistentHostCom::persistence" name="persistence">
      <type builtin="yes" name="bool" />
    </argument>
  </method>
  <method id="State::addComChannel" name="addComChannel">
    <return>
      <type builtin="yes" name="void" />
    </return>
    <argument id="State::addComChannel::ch" name="ch">
      <type name="gparse::Com &amp;&amp;" />
    </argument>
  </method>
</classtemplate>
