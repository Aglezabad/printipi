<?xml version='1.0' encoding='utf-8'?>
<class id="iodrv::RCThermistor2Pin" name="RCThermistor2Pin" xmlns="http://jessevdk.github.com/cldoc/1.0">
  <doc>
This class provides code to approximate a temperature via first determining the resistance of a thermistor
  (resistor that varies its resistance according to temperature) via only a digital IO pin, fixed resistor and capacitor.
The raspberry pi doesn't have any ADC pins, so we must use the method outlined below.
The implementation is designed to be compatible with ramps-fd.

               Vcc
                \
                / Rup
                \
        Rseries /        Rchrg
     o---/\/\/\-+-----o-/\/\/\-o
     \         _|_             |
     / therm   ___ C           |
     \          |              |
  THERMPIN     GND          CHRG/MEAS

 On ramps-fd Rup = 4.7k, Rseries = 22 ohm.
 Rchrg can be anything &gt; ~200 ohms - make sure not to draw more than 16 mA from a pin.
 If drawing a significant amount of current, make sure to configure the Pi's pin drive strength first.
 Recommended Rchrg value is 1k ohm. The ratio Rchrg / Rup should be significantly less than 0.5 to ensure that the pin state actually changes
 Also, Rseries should be such that the thermistor resistance + Rseries is always such that &lt; 16 mA is drawn.

 Note: in the case that Rchrg = 0, therm = infinite, discharge time = 0.69*RC = 32.8 mS with Rup=4k7, C=10.1e-6, Vtoggle=1.65
   so that's the absolute longest discharge time.

 Solve for Vcap(t) during a read:
 Iin = (Vcc-Vcap)/Rup + (Vcc-Vcap)/(therm+Rseries) where Iin is the current entering C, and THERMPIN is tied to +Vcc
 capacitor equation: Q = CV, or, I = C*dV/dt
 So, (Vcc-Vcap) * (1/Rup + 1/(therm+Rseries)) = C*Vcap'
   (Vcc-Vcap) * (Rup + therm + Rseries) / (C*Rup*(therm+Rseries)) = Vcap'
 Vcc-Vcap = Vcap' * (C*Rup*(therm+Rseries)) / (Rup + therm + Rseries)
 Vcap'*(C*Rup*(therm+Rseries))/(Rup + therm + Rseries) + Vcap = Vcc
   let Vcap = (V0-Vfinal)*e^(l*t) + Vfinal
   Consider the circuit configured with THERMPIN = no-connect, CHRG/MEAS=gnd for a long time before t=0:
   then Vcap = k*e^(l*t) + Vcc where k = V0-Vcc.
     V0 = Vcc * Rchrg / (Rchrg + Rup),
     so *k = Vcc*(Rchrg / (Rchrg + Rup) - 1)
   then Vcap' = k*l*e^(l*t)
 k*l*e^(l*t)*(C*Rup*(therm+Rseries))/(Rup + therm + Rseries) + k*e^(l*t) + Vcc = Vcc
 k*e^(l*t) * [l*(C*Rup*(therm+Rseries))/(Rup + therm + Rseries) + 1] = 0
   So, l = -1 / [(C*Rup*(therm+Rseries))/(Rup + therm + Rseries)]
   *l = -(Rup + therm + Rseries) / (C*Rup*(therm+Rseries))

 From the read, we can know Vcap(tr) = Vtoggle
 From this, we want to solve for therm:
 Vtoggle = k * e^(l*tr) + Vcc
 (Vtoggle-Vcc)/k = e^(l*tr)
 1.0/tr*ln((Vtoggle-Vcc)/k) = l = -(Rup + therm + Rseries) / (C*Rup*(therm+Rseries))
 C*Rup*(therm+Rseries)/tr*ln((Vtoggle-Vcc)/k) = -(Rup + therm + Rseries)
 therm* C*Rup/tr*ln((Vtoggle-Vcc)/k) + C*Rup*Rseries/tr*ln((Vtoggle-Vcc)/k) + therm = -Rup - Rseries
 therm[1+C*Rup/tr*ln((Vtoggle-Vcc)/k)] = C*Rup*Rseries/tr*ln((Vtoggle-Vcc)/k) - Rup - Rseries
 let denom = [1+C*Rup/tr*ln((Vtoggle-Vcc)/k)],
 then therm = (C*Rup*Rseries/tr*ln((Vtoggle-Vcc)/k) - Rup - Rseries) / denom
</doc>
  <constructor id="iodrv::RCThermistor2Pin::RCThermistor2Pin" name="RCThermistor2Pin">
    <argument id="iodrv::RCThermistor2Pin::RCThermistor2Pin::thermPin" name="thermPin">
      <type name="IoPin &amp;&amp;" />
    </argument>
    <argument id="iodrv::RCThermistor2Pin::RCThermistor2Pin::chargeMeasPin" name="chargeMeasPin">
      <type name="IoPin &amp;&amp;" />
    </argument>
    <argument id="iodrv::RCThermistor2Pin::RCThermistor2Pin::RCHRG_OHMS" name="RCHRG_OHMS">
      <type builtin="yes" name="float" />
    </argument>
    <argument id="iodrv::RCThermistor2Pin::RCThermistor2Pin::RSERIES_OHMS" name="RSERIES_OHMS">
      <type builtin="yes" name="float" />
    </argument>
    <argument id="iodrv::RCThermistor2Pin::RCThermistor2Pin::RUP_OHMS" name="RUP_OHMS">
      <type builtin="yes" name="float" />
    </argument>
    <argument id="iodrv::RCThermistor2Pin::RCThermistor2Pin::C_FARADS" name="C_FARADS">
      <type builtin="yes" name="float" />
    </argument>
    <argument id="iodrv::RCThermistor2Pin::RCThermistor2Pin::VCC_V" name="VCC_V">
      <type builtin="yes" name="float" />
    </argument>
    <argument id="iodrv::RCThermistor2Pin::RCThermistor2Pin::V_TOGGLE_V" name="V_TOGGLE_V">
      <type builtin="yes" name="float" />
    </argument>
    <argument id="iodrv::RCThermistor2Pin::RCThermistor2Pin::T0_C" name="T0_C">
      <type builtin="yes" name="float" />
    </argument>
    <argument id="iodrv::RCThermistor2Pin::RCThermistor2Pin::R0_OHMS" name="R0_OHMS">
      <type builtin="yes" name="float" />
    </argument>
    <argument id="iodrv::RCThermistor2Pin::RCThermistor2Pin::BETA" name="BETA">
      <type builtin="yes" name="float" />
    </argument>
  </constructor>
  <method id="iodrv::RCThermistor2Pin::isReady" name="isReady">
    <brief>called during the read.</brief>
    <return>
      <type builtin="yes" name="bool" />
    </return>
  </method>
  <method id="iodrv::RCThermistor2Pin::startRead" name="startRead">
    <return>
      <type builtin="yes" name="void" />
    </return>
  </method>
  <method id="iodrv::RCThermistor2Pin::timeSinceStartRead" name="timeSinceStartRead">
    <brief>need to expose this information to assist in detecting freezes / failed reads.</brief>
    <return>
      <type name="plat::generic::ChronoClock::duration" ref="plat::generic::ChronoClock#plat::generic::ChronoClock::duration" />
    </return>
  </method>
  <method id="iodrv::RCThermistor2Pin::value" name="value">
    <return>
      <type builtin="yes" name="float" />
    </return>
  </method>
</class>
